# 笔记
##　3-1 页面入口+header 组件的编写

### 安装依赖

```
# babel-runtime 会对一些ES6的语法做转译，用于提供编译模块的工具函数，fastclick可以解决移动端点击300ms延迟的问题
npm i babel-runtime fastclick -S

# 对一些ES6的API，如promise等做转译
npm i babel-polyfill -D
```

babel-runtime用于辅助es6的编译，不需要在代码中引入，而babel-polyfill需要直接在main.js中引入

### 配置別名

```js
// vue.config.js
var path = require('path')
module.exports = {
  configureWebpack: {
    resolve: {
      alias: {
        '@@': path.join(__dirname, '/src/components'),
        common: path.join(__dirname, '/src/common'),
        // 用于styl引入样式时使用
        styl: path.join(__dirname, '/src/common/stylus')
      }
    }
  },
  productionSourceMap: false
}
```



##　4-2 jsonp原理介绍+Promise封装

jsonp原理：动态创建script标签，script标签不受同源策略限制，从而实现实现跨域。具体是先在本地创建一个回调函数，用于在获取数据后执行。然后在script的src指向需要请求的服务器地址url，并将本地回调函数的名字发给服务器,这个地址会根据你发送过来的回调函数的名字，返回一个脚本，脚本内有一个自执行函数，会执行之前我们创建的回调函数，并将从服务器返回的数据传入。script加载后执行该方法即实现了一次跨域通信。



## 4-12 vue-lazyload 懒加载插件介绍和应用

尽管早就用过这项技术了，不过还是复习一下。

懒加载的作用：

- 减少服务器的请求
- 节省移动端的流量
- 少加载了用不到的资源，从而加快了加载速度

```js
// main.js
import Vue from 'vue'
import VueLazyLoad from 'vue-lazyload'
Vue.use(VueLazyLoad)

// 在需要懒加载的img 将:src改成v-lazy
```



better-scroll与fastclick库的冲突导致点击无效，可以通过给需要点击的dom加一个类名：`needsclick`来解决

## 5-3 歌手数据处理和 Singer 类的封装

```js
// charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
```



## 5-4~第五章结束

变量的设置：对于不需要监听的变量，不要直接设置在data中，因为设置在data中的数据会自动设置setter和getter，可以在created这个生命周期钩子中配置这些变量

触摸事件：

```js
e.touches // 每个触摸事件都包含，当前位于屏幕上的所有手指触摸点的一个列表
```

##　6-2 子路由配置以及转场动画实现
子路由：路由是靠组件去承载的，子路由也同样需要组件去承载

子路由的配置：

1.配置路由

```js
// /router/index.js
// 每个路由都有一个children字段可以配置子路由
[
  {
  	path:'/singer',
  	component:Singer,
    children:[
      {
        path:':id',
        component:SingerDetail
      }
    ]
	}
]
```



2.用router-view承载子路由

```vue
<template>
	<div>
    <div></div>
		<router-view></router-view>
  </div>
</template>
```



## 6-3 初识 Vuex

3W : what/why/how

vuex是什么、为什么有vuex出现、vuex怎样解决这些问题

vuex是一套状态管理模式。

它是为了让状态的修改可以预测。

因此他设计了以下流程：



vuex:

State --Render--> vue components --Dispatch--> Actions --commit--> Mutations --Mutate--> State



使用vuex时组件是无法直接修改数据的，只能通过dispatch到Actions或者commit到Mutations来修改数据。因此使用vuex实际上会让数据修改变得更加的繁琐。我们知道技术的产生都是为了解决问题的，vuex明明这么麻烦，人们还特意要去使用它？事实上，就是因为在某些场景下的痛点需要解决，才导致了vuex的诞生。



在一个复杂应用中，数据被一些组件共享，而这些组件可能关联度很低，这时想要共享数据是很困难的，而数据共享后，又有一个问题：这些数据同时被多个组件使用（读取和修改），维护起来也是很困难的。

vuex就是用来解决多组件之间的状态共享，路由间的复杂数据传递